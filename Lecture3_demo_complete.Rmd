---
title: "Lecture 3 Demo"
output: pdf_document
---

**Quiz?**

# Review

Before we dive too deep into the material, let's review what we've learned so far:

**if-else statement**

```         
if(condition){
  action
} else {
  action
}
```

**for loop**

```         
for(item in items){
  action_with_item
}
```

**function**

```         
function(input){
  action_with_input
}
```

Notice a pattern here? The `if`, `for`, and `function` statements all have a similar format! In general, **when we are writing R code that's run in a special way (run only sometimes or run repeatedly)**, we provide some type of instructions in parentheses `()`. Then we provide the code we want to run based on those instructions in curly brackets `{}`. We need those curly brackets `{}` to tell R what code we want run in the special way and what code is just run normally.

Note that `for` and `function` both allow you to create new variables inside the parentheses `()` that you can use later inside the curly brackets `{}`.

Want some more practice with these? Check out [while loops](https://www.w3schools.com/r/r_while_loop.asp) which use the same format!

# Functions

Functions are a way to do the same action to different inputs.

*Sam's real-world example of using functions to make reports for a clinical trial*

Functions have 2 important parts:

1.  The part that goes in parentheses is the input. Not all functions have inputs, and that's okay.
2.  The part that goes in the curly brackets is the the action that you want to repeat over and over again.

You can then call on a function using its name and putting the input inside parentheses.

```{r}
printer = function(input){
  print(input)
}

printer(input="Hello world")
printer(input="Go trees!")
```

## Different Inputs

We tell our function to expect inputs by putting names in parentheses.

```{r}
exponentiate = function(base, exponent){
  base ^ exponent
}
```

We then call on our function to do its work using its name with the inputs in parentheses.

```{r}
exponentiate(base=2, exponent=4)
```

If we know the order of the inputs, we don't have to give them names. It's a good idea to use the names as often as possible to avoid getting confused and mixing up the inputs.

```{r}
# We want to calculate 3 to the 4th power

# This works
exponentiate(base=3, exponent=4)
exponentiate(exponent=4, base=3)

# This also works
exponentiate(3, 4)

# But this does not give us the right answer
exponentiate(4, 3)
```

Some functions have no inputs. They will always do the same thing.

```{r}
ping = function(){
  print("PONG!")
}

ping()
ping()
ping()
```

Some functions use `…` in their inputs. This `…` means that the function will take unlimited inputs and the names are optional. You don't have to worry about writing functions like this, but we will see functions next week that just have `…` as their input.

```{r}
combine_into_vector = function(...){
  c(...)
}

# Write any number of elements to add into a vector
combine_into_vector(1,2,3,4,5,6,7)
```

We can also write our functions with default values for the inputs using the equal sign in the parentheses. This makes those inputs optional for people calling the function. If they call the function without specifying that input, the function will use the default value.

```{r}
new_exponentiate = function(base, exponent=1){
  base^exponent
}

new_exponentiate(base=2)
#exponentiate(base=2) # Will give an error
new_exponentiate(base=2, exponent=2)
```

## Returning Outputs

Usually, we want functions to do something with the input and then give it back to us, called "returning", so that we can use it later in our code. You can see in the above examples that R will return the most recent calculation it did.

```{r}
what_will_this_return = function(input1, input2, input3, input4){
  input1+input3
  if(input4>input3){
    input2*input3
  }
  input1-input2
}

what_will_this_return(0, 2, 10, 4)
```

Sometimes, if something is true, we want to stop the function early and return a value. We can do this using the `return()` function. For example, let's write a division function. However, remember that you cannot divide by zero.

```{r}
# Write your own function to divide two numbers
# Remember that you cannot divde by zero
division = function(numerator, denominator){
  if(denominator==0){
    return("Not possible!")
  }
  numerator/denominator
}

# Write some tests including trying to divide by zero
division(5, 2)
division(6, 0)
```

## Useful Built-In Functions

R has a bunch of functions that have already been written and documented for us. For example `min()` and `max()`:

```{r}
min(1,2,3,4,5)
max(1,2,3,4,5)
```

These functions have documentation to tell us how to use them. You access the documentation using the `?`.

```{r}
?min()
?max()
```

Looking at the documentation, it allows us to give any number of inputs using `…`, but it also has an option `na.rm` that is by default set to `FALSE`. According to the help screen, it indicates whether missing values should be removed. Let's try it out:

```{r}
min(1, 2, 6, NA, 6)
max(1, 2, 3, NA, 7, na.rm=T)
```

Luckily, we don't have to do the question mark each time. If you type in a function name and press `Tab`, it will give you some hints as to what you may be looking for. Let's try this with `sample` like we did in the pre-class work.

```{r}
sample(x=c("a","b","c"), size=3, replace=T, prob=c(1,0,0))
```

# Packages

Packages give us a bunch of different functions we can use to manipulate data, do complex calculations, and make pretty visualizations.

## Install & Library

To get the package on your computer, you use `install.packages()` with the package name in quotes inside the parentheses. To tell R you want to use that package in the R code you're working on, you use `library()` with the package name *not* in quotes.

```{r}
install.packages("tidyverse", repos="https://cloud.r-project.org")
library(tidyverse)
```

# Import Data

When you download data (or get it from collaborators), it's best practice to store it in your `data` folder. This organization prevents you from loosing things and makes it easy for us to get the data into R. The main way you will do this is with `read_csv()`. Note, you need to load the `tidyverse` package before you use `read_csv()`.

If someone sends you data in excel (which they shouldn't), you can use `read_excel()` in the `readxl` package.

Download `employment_data.csv` from R and save it to a variable. If you're using R Markdown, you'll need to use `here`.

```{r}
employment_data = read_csv(here::here("data/employment_data.csv"))
```

# Fun with Dates

Dates are notoriously hard to deal with. There are leap years and [leap seconds](https://www.youtube.com/watch?v=lv3KAvP--ZM). Some months have 30 days, some months have 31, and other months can't decide how many days they want to have. Also, there are a bunch of different ways of writing the same date.

## Lubridate Intro

Lubridate to the rescue! `lubridate` is one of the packages included in the `tidyverse`. For additional help getting started, you can check out the [Lubridate Cheat Sheet](https://rstudio.github.io/cheatsheets/lubridate.pdf). To create a date in `lubridate`, you will use one of the parsing functions. These functions take in strings and create dates.

```{r}
# Year, month, day, hours, minutes, seconds
ymd_hms("2024-01-02 03:04:05")

# Month, day, year, hours, minutes, seconds
mdy_hms("10/31/22 23:59:59")

# Year, month, day
ymd("2020-03-15")

# Month, day, year
mdy("1/24/24")

# It knows what days exist and what don't
ymd("2024-02-29")
ymd("2023-02-29")
```

Now you use the right functions to turn these written out dates into Lubridate dates. Use the cheat sheet to help!

```{r}
ymd("2024-01-01")
mdy("01-31-24")
dmy("31/01/24")
ymd_hm("2022-31-08 11:00")

# You can tranform these dates all at once!
mdy(c("11/08/16", "11/02/20", "11/05/24"))
```

## Employment Exercise

Our goal is to use the `employment_data` dataset you imported above to calculate the employee's total compensation over the time they've worked at The Company(TM).

### Step 1: Get the start date and end dates as Lubridates

Use the dataset and what you just learned to pull out the start dates and end dates and transform them into Lubridates.

```{r}
start_dates = ymd(employment_data$start_date)
end_dates = ymd(employment_data$end_date)
```

### Step 2: Fix the end dates

If people don't have an end date, they're still working at The Company(TM). So we need to replace all of the `NA`s in `end_date` with today's date. Check the cheat sheet to figure out how to get today's date.

```{r}
end_dates[is.na(end_dates)] = today()
end_dates
```

### Step 3: Figure out how long each person has been working here

Lubridate allows us to subtract dates just like any other number. Use this to calculate how long each employee has been working at The Company(TM).

```{r}
working_here = end_dates - start_dates
```

Lubridate also has a concept called an interval which stores the time between two dates accounting for leap years and everything else. Using `interval()` or `%--%`, create a vector of intervals that describes when each person works here.

```{r}
interval_working = interval(start_dates, end_dates)
interval_working2 = start_dates %--% end_dates
interval_working
```

### Step 4: Multiply the number of months the person has been working by their monthly salary

Note: The Company(TM) pays its employees the same amount regardless of how long a month is (because it's cheaper). We also don't pay people for partial months worked (because we're evil).

Lubridate allows us to divide dates like they're math. These functions include dividing an entire time span by another time span. For example:

```{r}
all_of_jan = interval(start=mdy("01-01-2024"), end=mdy("01-31-2024"))
all_of_jan/weeks(1)
```

Now take the intervals you made and get the number of whole months each person worked. Then multiply that by their monthly salary.

```{r}
num_months = floor(interval_working/months(1))
num_months2 = interval_working %/% months(1)

num_months*employment_data$monthly_salary
```
